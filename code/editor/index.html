<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Code Editor</title>
    <link rel="stylesheet" href="style.css" type="text/css">
    <script src="script.js" type="text/javascript" charset="utf-8"></script>

</head>
<body>
  <div id="header">
    <h1>Web-based Code Editor</h1>
  </div>
  <div id="content">
    <div id="options">
      <div id="language">
        Language: 
        <select id="languageselector" onchange="changeLanguage()">
          <option value="tcl">Tcl</option>
          <option value="xotcl">XoTcl</option>
          <option value="text">NX</option>
        </select>
      </div>
      <div id="sample">
        Scripts: 
        <select id="scriptselector" onchange="changeScript()">
          <option value="none">none</option>
          <option value="dijkstra">Dijkstra</option>
          <option value="checklist">Sample</option>
          <option value="intro">intro</option>
          <option value="xotcl">XoTcl</option>
        </select>
      </div>         
    </div>
    <div id="wrapper">
    <div id="editor"></div>
      <script src="src/ace.js" type="text/javascript" charset="utf-8"></script>
      <script>
        var editor = ace.edit("editor");
        editor.session.setMode("ace/mode/tcl");
        editor.setTheme("ace/theme/monokai");
      </script>
    </div>  
    <div id="operations">
      <input type="submit" value="Evaluate" onclick="submitToServer()"/>
    </div>
    <pre id="result">
    </pre>
  </div>
  
<script type="text/editor" id="none"></script>

<textarea class="sample" id="checklist">
#String
set y "xxxx" 
set y "xxxx "cssdsdsdsd" yyyy"

set x "xxxxxx
      sdsdasdasd
   ssadsadasd"

set y  "xxxx
       swfsfsdfsd
       "

#variables
set $name

set $name(key)

set ${name} 

set ${subst}$itut(ions)

set ${:name}

set $::x
set $::x::a
set $x::a

::tcl::set
nx::Object
::xotcl::Class


#command substitution

set y [set x 1]

set y "[set x 1] hallo"

# comment \
asdf \
adsf

kein comment

set x 1; # my comment \
         dsdsdsdds


set x \
   1

set y \
   "1"   
   
   
set x \1   

{*}
;
         
set x "\[set x 1 \]"

proc foo {p1} {;}

Object create foo;
Class create foo;

set x {x y z};

set x [list x y z]

set x {set set set}

set x {incr y; incr y}
eval $x

set x {x y z; x y z}

set x 1; set y 2
set z 3

proc foo {p1} {;}

proc foo {p1} {;} != proc foo {p1} {}; == proc foo {p1} {;};

proc foo {x y z} {;}


</textarea>

<textarea class="sample" id="intro">
# comments - there is only the concept of single-line comments
# each line of a multi-line comment block must be introduced by a "#"

puts "hello world"; # inline comments require a preceeding ";"
puts {hello world}; # grouping words by "{}" makes them literal strings (there is no variable substitution etc.)

# variable operations: naming, assignment, substitution
set x "hello world"
puts "x = $x"
puts {x = $x}; # no variable replacement occurs -> $x is printed, rather than 'hello world'
# 1. "[...]" blocks are evaluation blocks which are evaluated (executed)
# before printing the final string (kind of a #{...} block in ruby,
# but more powerful)
# 2. [set x] corresponds to $x, i.e., the [set] command acts a
# variable setter when supplied with two arguments and as a getter
# when there is only a single argument
puts "x = [set x]";

# variable naming: there are no syntactic conventions, except for
# using "$" as first character in a variable name (such as in
# javascript)
set first_name "russ"
set lastName "sobernig"

# in Tcl, there are no operators like + etc. for string manipulation,
# but there are various commands a [string] command

set _full_name "$first_name $lastName"; # string concatenation (within quotes)

puts "1. $_full_name"

# ... or the [append] and [string commands]
# http://docs.activestate.com/activetcl/8.5/tcl/TclCmd/append.htm
# http://docs.activestate.com/activetcl/8.5/tcl/TclCmd/string.htm

append _full_name2 $first_name " " $lastName

puts "2. $_full_name2"

# arithemtic operations must be performed by a special command: [expr]
# http://docs.activestate.com/activetcl/8.5/tcl/TclCmd/expr.htm

set x [expr {2 + 3 + 4 + 5}]
puts "x->$x"

# multi-line assignments
# `- multi-line strings: just a newline

set _full_name "$first_name 
lastName"

puts "_full_name->$_full_name"

# `- multi-line commands (!): use the backslash to bind lines
# NOTE: there must not be a white space following the "\" !!!

append _full_name2 $first_name \
    " " $lastName

puts "_full_name2->$_full_name2"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Home assignments: Complete the following tasks (based on the equivalent
# javascript and ruby examples)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

# if statements
if {1} {puts "7. hello world!"}

if {0} {puts "8. hello world!"}

set weight 50

if {$weight < 1} {
   puts "very light"
} elseif {$weight < 10} {
   puts "a bit of a load"
} elseif {$weight < 100} {
   puts "heavy"
} else {
   puts "way too heavy"
}

# while loop
set x 0
while {$x < 4} {
    puts "x = $x"
    incr x
}

# for loop
for {set x 0} {$x<4} {incr x} {
   puts "x = $x"
}

# for/in loop
#conform with ruby
set some_array {"first" "second" 3}
foreach idx $some_array {
    puts "$idx"
}

#conform with javascript structure
set some_array {"first" "second" 3}
set x 0
foreach idx $some_array {
    puts "$x -> $idx"
    incr x
}

# Container data structures: list (corresponds to arrays in other
# javascript and ruby)
# Note, there are individual commands for list management, i.e.,
# [llength], [lsort], [lappend]!
set x ""
set some_array "first second 3"

puts [lindex $some_array 0]
puts [lindex $some_array 1]
puts [lindex $some_array 2]

puts [llength $some_array]

set some_array [lreplace $some_array 2 2 "three"]

set some_array [linsert $some_array 3 4]

lappend some_array 5

puts [lindex $some_array 4]

# Container data structures: arrays (Tcl array are associative arrays,
# i.e., hashes. The name is misleading!

array set h {first_name Albert}
array set h {last_name Einstein}

puts $h(first_name)
puts $h(last_name)

#to ensure that the array h is empty
unset h

array set h {
  first_name Albert
  last_name Einstein
}

foreach k [array names h] {
   puts "value of '$k' ->: $h($k)"
}

# define a function "square()":

proc square x {
    set result [expr {$x * $x}]
}

#to be conform with ruby file
puts [square 2 ]




</textarea>

<textarea class="sample" id="xotcl">
package require XOTcl
namespace import ::xotcl::*

set opt(-symbol) YHOO
array set opt $argv

Class WebPage -parameter {{url http://nm.wu-wien.ac.at/}}

WebPage instproc parseUrl {} {
  my instvar url hostname port path
  if {[regexp {http://([^/]+)(/?.*)} $url _ hostname path]} {
    if {![regexp ^(.*):(.*)$ $hostname _ hostname port]} {
      set port 80     ;# Standardannahme
    }
    if {$path == ""} {set path /}
  }
}

WebPage instproc loadPage {{headerFields ""}} {
  my instvar hostname port path content
  my parseUrl
  set stream [socket $hostname $port]
  puts $stream "GET $path HTTP/1.0"
  puts $stream "Host: $hostname"
  foreach {tag value} $headerFields {puts $stream "$tag: $value"}
  puts $stream ""
  flush $stream
  set content [read $stream]
  close $stream
}
WebPage instproc getContent {} {
  my instvar content
  if {![my exists content]} { my loadPage }
  return $content
}


Class Stock -parameter {{symbol ""}}

Stock instproc extractData {content} {
  my instvar timeVar rate bid ask openVar volume
  if {![regexp {<div class=\"rtq_div\">(.*)Add to Portfolio} $content _ header]} {
  	puts stderr "could not extract header"
  } else {
    regexp {time_rtq_ticker\"><[^>]*>(.*)</span></span> <span class=\"down_r} $header _ rate
  regexp {time_rtq\"> <[^>]*>(.*)</span></span>.*\|} $header _ timeVar
  }

  if {![regexp {<div id=\"yfi_quote_summary_data(.*)Avg Vol } $content _ data]} {
  	puts stderr "could not extract data part"
  } else {
    regsub -all {</?tr/?>} $data "" data
    regsub -all {</?td[^>]*>} $data "" data
    regsub -all {</?th[^>]*>} $data "" data
    regsub -all {</?span[^>]*>} $data "" data
    regsub -all {</?table[^>]*>} $data "" data
    regsub -all {</?small>} $data "" data
    
    regexp {Bid:(.*)Ask} $data _ bid
    regexp {Ask:(.*)1y} $data _ ask
    regexp {Open:(.*)Bid} $data _ openVar
    regexp {Volume:(.*)} $data _ volume
  }
}

Stock instproc printData {} {
  my instvar symbol timeVar rate bid ask openVar volume
  if {[my exists timeVar] && [info exists rate] && [info exists bid] && [info exists ask] && [info exists openVar] && [info exists volume]} {
   puts "The current rate of symbol $symbol at $timeVar is $rate with following details:"
   puts "Bid: $bid"
   puts "Ask: $ask"
   puts "Open: $openVar"
   puts "Volume: $volume"
  } else {
   puts stderr "The data could not be extracted for $symbol"
  }
}

WebPage stockinfo -url http://finance.yahoo.com/q?s=$opt(-symbol)&d=1b

Stock s -symbol $opt(-symbol)
s extractData [stockinfo getContent]
s printData
</textarea>



<textarea class="sample" id="dijkstra">

proc dijkstra {graph origin} {
    # Initialize
    dict for {vertex distmap} $graph {
	dict set dist $vertex Inf
	dict set path $vertex {}
    }
    dict set dist $origin 0
    dict set path $origin [list $origin]
 
    while {[dict size $graph]} {
	# Find unhandled node with least weight
	set d Inf
	dict for {uu -} $graph {
	    if {$d > [set dd [dict get $dist $uu]]} {
		set u $uu
		set d $dd
	    }
	}
 
	# No such node; graph must be disconnected
	if {$d == Inf} break
 
	# Update the weights for nodes lead to by the node we've picked
	dict for {v dd} [dict get $graph $u] {
	    if {[dict exists $graph $v]} {
		set alt [expr {$d + $dd}]
		if {$alt < [dict get $dist $v]} {
		    dict set dist $v $alt
		    dict set path $v [list {*}[dict get $path $u] $v]
		}
	    }
	}
 
	# Remove chosen node from graph still to be handled
	dict unset graph $u
    }
    return [list $dist $path]
}
</textarea>


</body>
</head>
